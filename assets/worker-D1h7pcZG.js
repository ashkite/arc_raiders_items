var v=Object.defineProperty;var _=(o,e,r)=>e in o?v(o,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):o[e]=r;var k=(o,e,r)=>_(o,typeof e!="symbol"?e+"":e,r);const j="https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2/dist/transformers.min.js",y="Xenova/clip-vit-base-patch16";let g=null;async function E(){if(!g){console.log("[Worker] Importing transformers from CDN...");try{const o=await import(j);g=o.default||o,console.log("[Worker] Transformers module keys:",Object.keys(g)),g.env||o.env&&(g.env=o.env);const e={allowLocalModels:!1,allowRemoteModels:!0,useBrowserCache:!0};g.env&&Object.assign(g.env,e),self.transformers&&self.transformers.env&&Object.assign(self.transformers.env,e),console.log("[Worker] Transformers loaded and configured.")}catch(o){throw console.error("[Worker] Failed to load transformers from CDN:",o),o}}return g}class b{static async getInstance(){const e=await E(),r=e.CLIPVisionModelWithProjection||e.CLIPVisionModel||e.AutoModel,{AutoProcessor:a}=e;if(!r||!a)throw new Error(`Failed to load VisionModel or AutoProcessor. Keys: ${Object.keys(e)}`);return this.modelPromise||(console.time("Loading Model"),console.log(`Loading CLIP vision model (${y})...`),this.modelPromise=r.from_pretrained(y,{quantized:!0}),this.processorPromise=a.from_pretrained(y),await Promise.all([this.modelPromise,this.processorPromise]),console.timeEnd("Loading Model")),Promise.all([this.modelPromise,this.processorPromise])}}k(b,"modelPromise",null),k(b,"processorPromise",null);const M=o=>{let e=0;for(let r=0;r<o.length;r++)e+=o[r]*o[r];return e=Math.sqrt(e)||1,Array.from(o,r=>r/e)},L=(o,e)=>{const r=Math.min(o.length,e.length);let a=0;for(let t=0;t<r;t++)a+=o[t]*e[t];return a};let W=null;const O=async()=>(W||(console.log("[Worker] Loading embeddings.json..."),W=(async()=>{try{const e="/arc_raiders_items/"+"embeddings.json?v="+Date.now(),r=await fetch(e);if(!r.ok)throw new Error(`Failed to fetch embeddings: ${r.status}`);const a=await r.json(),t={};return Object.entries(a).forEach(([s,l])=>{Array.isArray(l)&&(t[s]=M(l))}),console.log(`[Worker] Loaded ${Object.keys(t).length} embeddings.`),t}catch(o){throw console.error("[Worker] Failed to load embeddings:",o),o}})()),W),I=async o=>{console.log(`[Worker] embedBatch: Processing ${o.length} images...`);const{RawImage:e}=await E(),[r,a]=await b.getInstance();console.log("[Worker] Reading images...");const t=await Promise.all(o.map(d=>e.read(d)));console.log("[Worker] Preprocessing images...");const s=await a(t);console.log("[Worker] Running model inference...");const l=await r(s);console.log("[Worker] Inference complete.");const f=l.image_embeds||l.pooler_output||l.last_hidden_state;if(!f||!f.data)throw console.error("[Worker] Invalid model output:",l),new Error("Model output is missing embeddings data.");const A=f.data,i=f.dims;if(!i||i.length<2)throw new Error(`Invalid output dimensions: ${i}`);const p=i[0],u=i[1];console.log(`[Worker] Output dims: [${p}, ${u}]`);const h=[];for(let d=0;d<p;d++){const c=d*u,n=c+u,m=Array.from(A.slice(c,n));h.push(M(m))}return h};self.onmessage=async o=>{const{id:e,type:r,images:a,candidatesList:t}=o.data;if(console.log(`[Worker] Received message: ${r} (ID: ${e})`),r==="init"){try{await E(),await b.getInstance();try{console.time("Warm-up"),console.log("[Worker] Starting warm-up..."),await I(["data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg=="]),console.timeEnd("Warm-up"),console.log("[Worker] Warm-up complete.")}catch(s){console.warn("Warm-up failed (non-fatal):",s)}self.postMessage({id:e,status:"ready"})}catch(s){console.error("Worker Init Error:",s),self.postMessage({id:e,status:"error",error:s instanceof Error?s.message:"Initialization failed"})}return}if(r==="analyze_batch"){try{console.time(`BatchInference-${e}`),console.log("[Worker] Start loading embeddings for batch...");const s=await O();console.log("[Worker] Embeddings loaded. Starting batch embedding...");const l=await I(a);console.timeEnd(`BatchInference-${e}`);const f=l.map((A,i)=>{const p=t&&t[i]&&t[i].length>0?t[i]:Object.keys(s);let u=p;if(t&&t[i]&&t[i].length>0){const c=Object.keys(s),n=new Set;p.forEach(m=>{s[m]&&n.add(m),c.forEach(w=>{w.startsWith(m+"__bg_")&&n.add(w)})}),u=Array.from(n)}const h=new Map;u.forEach(c=>{const n=s[c];if(!n)return;const m=L(A,n),w=c.split("__bg_")[0],P=h.get(w)||-1;m>P&&h.set(w,m)});const d=Array.from(h.entries()).map(([c,n])=>({label:c,score:n}));return d.length===0?[{label:"Unknown",score:0}]:(d.sort((c,n)=>n.score-c.score),d.slice(0,5))});self.postMessage({id:e,status:"success",results:f})}catch(s){console.error("Worker Batch Error:",s),self.postMessage({id:e,status:"error",error:s instanceof Error?s.message:"Unknown error"})}return}};
