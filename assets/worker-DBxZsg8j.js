var E=Object.defineProperty;var M=(o,e,r)=>e in o?E(o,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):o[e]=r;var p=(o,e,r)=>M(o,typeof e!="symbol"?e+"":e,r);const v="https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2/dist/transformers.min.js",w="Xenova/clip-vit-base-patch16";let c=null;async function b(){if(!c){console.log("[Worker] Importing transformers from CDN...");try{const o=await import(v);c=o.default||o,console.log("[Worker] Transformers module keys:",Object.keys(c)),c.env||o.env&&(c.env=o.env);const e={allowLocalModels:!1,allowRemoteModels:!0,localModelPath:"/models/",useBrowserCache:!1};c.env&&Object.assign(c.env,e),self.transformers&&self.transformers.env&&Object.assign(self.transformers.env,e),console.log("[Worker] Transformers loaded and configured.")}catch(o){throw console.error("[Worker] Failed to load transformers from CDN:",o),o}}return c}class f{static async getInstance(){const e=await b(),r=e.CLIPVisionModelWithProjection||e.CLIPVisionModel||e.AutoModel,{AutoProcessor:n}=e;if(!r||!n)throw new Error(`Failed to load VisionModel or AutoProcessor. Keys: ${Object.keys(e)}`);return this.modelPromise||(console.time("Loading Model"),console.log(`Loading CLIP vision model (${w})...`),this.modelPromise=r.from_pretrained(w,{quantized:!0}),this.processorPromise=n.from_pretrained(w),await Promise.all([this.modelPromise,this.processorPromise]),console.timeEnd("Loading Model")),Promise.all([this.modelPromise,this.processorPromise])}}p(f,"modelPromise",null),p(f,"processorPromise",null);const W=o=>{let e=0;for(let r=0;r<o.length;r++)e+=o[r]*o[r];return e=Math.sqrt(e)||1,Array.from(o,r=>r/e)},j=(o,e)=>{const r=Math.min(o.length,e.length);let n=0;for(let t=0;t<r;t++)n+=o[t]*e[t];return n};let A=null;const R=async()=>(A||(console.log("[Worker] Loading embeddings.json..."),A=(async()=>{try{const e="/arc_raiders_items/"+"embeddings.json",r=await fetch(e);if(!r.ok)throw new Error(`Failed to fetch embeddings: ${r.status}`);const n=await r.json(),t={};return Object.entries(n).forEach(([s,i])=>{Array.isArray(i)&&(t[s]=W(i))}),console.log(`[Worker] Loaded ${Object.keys(t).length} embeddings.`),t}catch(o){throw console.error("[Worker] Failed to load embeddings:",o),o}})()),A),y=async o=>{console.log(`[Worker] embedBatch: Processing ${o.length} images...`);const{RawImage:e}=await b(),[r,n]=await f.getInstance();console.log("[Worker] Reading images...");const t=await Promise.all(o.map(a=>e.read(a)));console.log("[Worker] Preprocessing images...");const s=await n(t);console.log("[Worker] Running model inference...");const i=await r(s);console.log("[Worker] Inference complete.");const g=i.image_embeds||i.pooler_output||i.last_hidden_state;if(!g||!g.data)throw console.error("[Worker] Invalid model output:",i),new Error("Model output is missing embeddings data.");const u=g.data,l=g.dims;if(!l||l.length<2)throw new Error(`Invalid output dimensions: ${l}`);const h=l[0],d=l[1];console.log(`[Worker] Output dims: [${h}, ${d}]`);const m=[];for(let a=0;a<h;a++){const k=a*d,I=k+d,P=Array.from(u.slice(k,I));m.push(W(P))}return m};self.onmessage=async o=>{const{id:e,type:r,images:n,candidatesList:t}=o.data;if(console.log(`[Worker] Received message: ${r} (ID: ${e})`),r==="init"){try{await b(),await f.getInstance();try{console.time("Warm-up"),console.log("[Worker] Starting warm-up..."),await y(["data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg=="]),console.timeEnd("Warm-up"),console.log("[Worker] Warm-up complete.")}catch(s){console.warn("Warm-up failed (non-fatal):",s)}self.postMessage({id:e,status:"ready"})}catch(s){console.error("Worker Init Error:",s),self.postMessage({id:e,status:"error",error:s instanceof Error?s.message:"Initialization failed"})}return}if(r==="analyze_batch"){try{console.time(`BatchInference-${e}`),console.log("[Worker] Start loading embeddings for batch...");const s=await R();console.log("[Worker] Embeddings loaded. Starting batch embedding...");const i=await y(n);console.timeEnd(`BatchInference-${e}`);const g=i.map((u,l)=>{const d=(t&&t[l]&&t[l].length>0?t[l]:Object.keys(s)).map(m=>{const a=s[m];return a?{label:m,score:j(u,a)}:null}).filter(Boolean);return d.length===0?{label:"Unknown",score:0}:(d.sort((m,a)=>a.score-m.score),d[0])});self.postMessage({id:e,status:"success",results:g})}catch(s){console.error("Worker Batch Error:",s),self.postMessage({id:e,status:"error",error:s instanceof Error?s.message:"Unknown error"})}return}};
